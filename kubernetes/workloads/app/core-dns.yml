apiVersion: apps/v1
kind: Deployment
metadata:
  name: coredns-stress-test
  namespace: app-namespace
  labels:
    app: dns-load-generator
spec:
  replicas: 2  # Respecte la politique restrict-scale (<3)
  selector:
    matchLabels:
      app: dns-load-generator
  template:
    metadata:
      labels:
        app: dns-load-generator
    spec:
      containers:
      - name: dns-query-flood
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          # Créer le fichier pour les health probes
          touch /tmp/healthy || echo "Cannot create /tmp/healthy"
          
          # Fonction pour générer des noms de domaine aléatoires
          gen_random_domain() {
            echo "random-$(date +%s%N | sha256sum | head -c 16).test.local"
          }
          
          # Boucle infinie de requêtes DNS
          while true; do
            # Générer des centaines de requêtes DNS non-mises en cache
            for i in $(seq 1 500); do
              random_domain=$(gen_random_domain)
              
              # Tenter plusieurs méthodes en cas d'échec (certaines peuvent ne pas être disponibles)
              host $random_domain 2>/dev/null || \
              nslookup $random_domain 2>/dev/null || \
              dig $random_domain 2>/dev/null || \
              getent hosts $random_domain 2>/dev/null || \
              echo "$random_domain" | xargs -I{} sh -c 'ping -c 1 -W 1 {} >/dev/null 2>&1' || \
              echo "DNS query attempt failed"
            done
            
            # Courte pause pour éviter que le pod ne soit considéré comme dysfonctionnel
            sleep 0.5
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5

      - name: cluster-service-resolver
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          # Créer le fichier pour les health probes
          touch /tmp/healthy || echo "Cannot create /tmp/healthy"
          
          # Liste des services à résoudre en continu
          echo "Commençant résolution service..."
          while true; do
            # Résoudre tous les services .cluster.local potentiels
            # Génération exhaustive de combinaisons de services dans différents namespaces
            for ns in default kube-system kube-public app-namespace db-namespace; do
              for svc in kubernetes coredns metrics-server dashboard api gateway frontend backend database; do
                for i in $(seq 1 5); do
                  host "$svc.$ns.svc.cluster.local" 2>/dev/null || \
                  getent hosts "$svc.$ns.svc.cluster.local" 2>/dev/null || \
                  echo "Lookup attempt: $svc.$ns.svc.cluster.local"
                done
              done
            done
            
            # Résoudre les headless services avec toutes les combinaisons possibles de pod names
            for name in "coredns" "kube-dns"; do
              for i in $(seq 0 9); do
                host "$name-$i.kube-dns.kube-system.svc.cluster.local" 2>/dev/null || \
                echo "Lookup headless: $name-$i"
              done
            done
            
            sleep 0.1
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5

      - name: reverse-lookup-flood
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          # Créer le fichier pour les health probes
          touch /tmp/healthy || echo "Cannot create /tmp/healthy"
          
          # Générer des requêtes de résolution inverse
          while true; do
            # Tenter des résolutions inverses sur toutes les adresses IP possibles du réseau interne
            for octet3 in $(seq 0 255); do
              for octet4 in $(seq 1 254); do
                if [ $((octet4 % 50)) -eq 0 ]; then
                  ip="10.96.$octet3.$octet4"
                  host $ip 2>/dev/null || \
                  getent hosts $ip 2>/dev/null || \
                  echo "Reverse lookup: $ip"
                fi
              done
              
              # Pause pour éviter trop de charge d'un coup
              sleep 0.01
            done
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          
      - name: dns-recursive-resolver
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          # Créer le fichier pour les health probes
          touch /tmp/healthy || echo "Cannot create /tmp/healthy"
          
          # Tenter des requêtes DNS récursives complexes
          while true; do
            # Liste des domaines externes complexes à résoudre
            domains=(
              "very-long-subdomain.with-many-parts.and-complex-resolution.example.com"
              "another-long-domain.with-multiple.levels.of.complexity.test.example.org"
              "deeply.nested.domain.with.lots.of.parts.that.requires.multiple.lookups.example.net"
              "random-$(date +%s).complex.example.io"
            )
            
            # Faire plusieurs tentatives de résolution pour chaque domaine
            for domain in "${domains[@]}"; do
              for i in $(seq 1 20); do
                host $domain 2>/dev/null || \
                getent hosts $domain 2>/dev/null || \
                echo "Complex DNS query: $domain"
              done
            done
            
            sleep 0.5
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
