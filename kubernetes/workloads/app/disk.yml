apiVersion: apps/v1
kind: Deployment
metadata:
  name: disk-saturation
  namespace: app-namespace
  labels:
    app: disk-saturation
spec:
  replicas: 2  # Un pod sur chaque nœud (si possible)
  selector:
    matchLabels:
      app: disk-saturation
  template:
    metadata:
      labels:
        app: disk-saturation
    spec:
      containers:
      - name: log-generator
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          touch /tmp/healthy
          # Générer des logs massifs
          while true; do
            for i in $(seq 1 200); do
              data=$(head -c 500000 /dev/urandom | base64)
              echo "ERROR: Large log data for diagnostics: $data" >&2
            done
            sleep 0.1
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
      
      - name: disk-filler
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          touch /tmp/healthy
          # Remplir emptyDir (espace disque du nœud)
          while true; do
            # Essayer de créer des fichiers de plus en plus gros
            for size in 100 200 500 1000 2000; do
              for i in $(seq 1 10); do
                dd if=/dev/zero of=/data/file-${size}MB-$i.bin bs=1M count=$size 2>/dev/null || \
                echo "Failed to write ${size}MB file"
                
                # Si on a réussi à écrire un gros fichier, continuer avec cette taille
                if [ $? -eq 0 ]; then
                  echo "Successfully wrote ${size}MB file"
                  # Tenter d'en écrire plusieurs autres de même taille
                  for j in $(seq 11 30); do
                    dd if=/dev/zero of=/data/file-${size}MB-$j.bin bs=1M count=$size 2>/dev/null
                  done
                fi
              done
            done
            
            # Si on ne peut plus écrire de gros fichiers, tenter avec des plus petits
            echo "Trying smaller files..."
            for i in $(seq 1 1000); do
              dd if=/dev/zero of=/data/small-$i.bin bs=1M count=10 2>/dev/null
            done
            
            # Pause avant de recommencer le cycle
            sleep 1
          done
        volumeMounts:
        - name: large-volume
          mountPath: /data
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
      
      - name: tmp-filler
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          touch /tmp/healthy
          # Remplir /tmp (généralement accessible en écriture même avec readOnlyRootFilesystem)
          while true; do
            # Tenter de créer beaucoup de petits fichiers pour saturer les inodes
            for i in $(seq 1 20000); do
              echo "data-$i-$(date +%s)" > /tmp/file-$i.txt 2>/dev/null
              
              # Tous les 1000 fichiers, vérifier si on peut continuer
              if [ $((i % 1000)) -eq 0 ]; then
                echo "Created $i files in /tmp"
              fi
            done
            
            # Tenter également de créer quelques gros fichiers
            for i in $(seq 1 20); do
              dd if=/dev/zero of=/tmp/bigfile-$i bs=1M count=50 2>/dev/null || \
              echo "Failed to create large file in /tmp"
            done
            
            sleep 1
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
      
      - name: sparse-file-creator
        image: alpine:latest
        command: ["/bin/sh", "-c"]
        args:
        - |
          touch /tmp/healthy
          # Créer des fichiers sparse (avec des "trous") qui semblent énormes
          # mais ne consomment de l'espace que là où on écrit
          while true; do
            for size in 10 20 50 100; do
              # Créer des fichiers sparse de différentes tailles (en GB)
              for i in $(seq 1 5); do
                echo "Creating ${size}GB sparse file $i..."
                dd if=/dev/zero of=/tmp/sparse-${size}G-$i.bin bs=1 count=0 seek=${size}G 2>/dev/null || \
                echo "Failed to create ${size}GB sparse file"
                
                # Si création réussie, écrire à des positions aléatoires pour consommer de l'espace réel
                if [ $? -eq 0 ]; then
                  for j in $(seq 1 100); do
                    # Position aléatoire dans le fichier (approximation bash)
                    pos=$((RANDOM * 1000 % (size * 1024)))
                    # Écrire 1MB à cette position
                    dd if=/dev/zero of=/tmp/sparse-${size}G-$i.bin bs=1M count=1 seek=$pos conv=notrunc 2>/dev/null
                  done
                fi
              done
            done
            
            sleep 1
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
        readinessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          exec:
            command: ["cat", "/tmp/healthy"]
          initialDelaySeconds: 5
          periodSeconds: 10
      
      volumes:
      - name: large-volume
        emptyDir:
          sizeLimit: 50Gi  # Demander un grand volume pour stocker les données
